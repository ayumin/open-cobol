\input texinfo
@setfilename gnucobol.info
@setcontentsaftertitlepage
@settitle GNU Cobol Manual
@setchapternewpage on
@footnotestyle end

@afourpaper

@include version.texi

@ifinfo
@dircategory COBOL
@direntry
* GNU Cobol: (gnucobol).      A COBOL compiler
@end direntry

This file documents GNU Cobol, a COBOL compiler

Copyright @copyright{} 2002,2003,2004,2005,2006,2007 Keisuke Nishida
Copyright @copyright{} 2007-2012 Roger While

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@titlepage
@title GNU Cobol Manual
@subtitle for GNU Cobol @value{VERSION}
@author Keisuke Nishida / Roger While

Edition @value{EDITION} @*
Updated for GNU Cobol @value{VERSION} @*
@value{UPDATED} @*

GNU Cobol is a free and open-source COBOL compiler, which translates
COBOL programs to C code and compiles it using GCC or other native
operating system C compiler.

This manual corresponds to GNU Cobol @value{VERSION}.

@vskip 0pt plus 1filll
Copyright @copyright{} 2002,2003,2004,2005,2006 Keisuke Nishida@*
Copyright @copyright{} 2007-2012 Roger While

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end titlepage

@node Top

@menu
* Getting Started::             Introduction to GNU Cobol
* Compile::                     Compiling COBOL programs
* Customize::                   Customizing the compiler
* Optimize::                    Optimizing your program
* Debug::                       Debugging your program
* System routines::				Additional routines 
* Appendix A::                  @code{cobc --help}
* Appendix B::                  @code{cobc --info}
* Appendix C::                  @code{cobc --list-reserved}
* Appendix D::                  @code{cobc --list-intrinsics}
* Appendix E::                  @code{cobc --list-system}
* Appendix F::                  @code{cobc --list-mnemonics}
* Appendix G::                  config/default.conf

@detailmenu
 --- The Detailed Node Listing ---

Getting Started

* Hello World!::                Hello World!

Compile

* Compiler Options::            Compiler options
* Multiple Sources::            Compiling multiple source files
* C Interface::                 Dealing with C files

Compiler Options

* Help Options::                Help Options
* Built Target::                Built Target
* Source Format::               Source Format
* Warning Options::             Warning Options
* Configuration Options::       Configuration Options
* Debug Switches::              Debug Switches
* Miscellaneous::               Miscellaneous

Multiple Sources

* Static Linking::              Compiling into a single executable
* Dynamic Linking::             A main program and separate modules
* Building Library::            Building a shared library
* Using Library::               Using external libraries

C Interface

* Main C Program::              Writing Main Program in C
* Static C to COBOL::           
* Dynamic C to COBOL::          
* Static COBOL to C::           
* Dynamic COBOL to C::          

Customize

* Customizing Compiler::        Customizing Compiler
* Customizing Library::         Customizing Library

Optimize

* Optimize Options::            How to enable optimization
* Optimize Call::               Call subroutines efficiently
* Optimize Binary::             Use efficient binary representation

Debug

* Debug Options::               Debug options

System routines

* CBL_OC_GETOPT					GETOPT for Cobol

Appendix A

Appendix B

Appendix C

Appendix D

Appendix E

Appendix F

Appendix G

@end detailmenu
@end menu

@node Getting Started, Compile, Top, Top
@chapter Getting Started

@menu
* Hello World!::                Hello World!
@end menu

@node Hello World!,  , Getting Started, Getting Started
@section Hello World!

This is a sample program that displays ``Hello World'':

@example
---- hello.cob -------------------------
      * Sample COBOL program
       IDENTIFICATION DIVISION.
       PROGRAM-ID. hello.
       PROCEDURE DIVISION.
       DISPLAY "Hello World!".
       STOP RUN.
----------------------------------------
@end example

The compiler is @code{cobc}, which is executed as follows:

@example
$ cobc -x hello.cob
$ ./hello
Hello World!
@end example

The executable file name (i.e., @file{hello} in this case) is
determined by removing the extension from the source file name.

You can specify the executable file name by specifying the compiler
option @code{-o} as follows:

@example
$ cobc -x -o hello-world hello.cob 
$ ./hello-world
Hello World!
@end example

Using more modern sources.

@example
---- hellonew.cob ----------------
*> Sample GNU Cobol program
identification division.
program-id. hellonew.
procedure division.
display
   "Hello New World!"
end-display
goback.
----------------------------------
@end example

@example
$ cobc -x -free hellonew.cob
$ ./hellonew
Hello New World!
@end example

Showing the use of free format, to end of line comments, the
@code{goback} verb, and proper use of terminator with
@code{end-display}.

@node Compile, Customize, Getting Started, Top
@chapter Compile

This chapter describes how to compile COBOL programs using GNU Cobol.

@menu
* Compiler Options::            Compiler options
* Multiple Sources::            Compiling multiple source files
* C Interface::                 Dealing with C files
@end menu

@node Compiler Options, Multiple Sources, Compile, Compile
@section Compiler Options

The compiler @code{cobc} accepts the options described in this section.@*
General syntax -@*
@code{cobc} [options] file [file ..]@*
A complete list of options can be displayed by using the help option.

@menu
* Help Options::                Help Options
* Built Target::                Built Target
* Source Format::               Source Format
* Warning Options::             Warning Options
* Configuration Options::       Configuration Options
* Debug Switches::              Debug Switches
* Miscellaneous::               Miscellaneous
@end menu

@node Help Options, Built Target, Compiler Options, Compiler Options
@subsection Help Options

The following switches can be used for informational displays:

@table @code
@item --help
Display help screen (@pxref{Appendix A, ,cobc --help}).
@code{-h} will also display the help.
No further actions will be taken except for further display options.

@item --version
Display compiler version, author package date and executable build
date.  @code{-V} will also display version.
No further actions will be taken except for further display options.

@item --info
Display build information (@pxref{Appendix B, ,cobc --info}).
No further actions will be taken except for further display options.

@item -v
Verbosely displays the programs invoked during compilations.

@item --list-reserved
Display reserved words(@pxref{Appendix C, ,cobc --list-reserved}).
A Y/N field shows if the word is supported.
@footnote{Support may be partial or complete}
No further actions will be taken except for further display options.

@item --list-intrinsics
Display intrinsic functions (@pxref{Appendix D, ,cobc --list-intrinsics}).
A Y/N field shows if the function is implemented.
No further actions will be taken except for further display options.

@item --list-system
Display system routines (@pxref{Appendix E, ,cobc --list-system}).
No further actions will be taken except for further display options.

@item --list-mnemonics
Display mnemonic names (@pxref{Appendix F, ,cobc --list-mnemonics}).
No further actions will be taken except for further display options.

@end table

@node Built Target, Source Format, Help Options, Compiler Options
@subsection Built Target

The @code{cobc} compiler can handle @file{*.cob}, @file{*.cbl} as
COBOL source code, @file{*.c} for C source code, @file{*.o} for
object code, @file{*.i} for preprocessed code and @file{*.so}
for dynamic modules and will do the right thing in terms of
generation, compilation, or link.

The following options specify the target type produced by the
compiler:

@table @code
@item -E
Preprocess only.  Compiler directives are executed.  Comment lines are
removed.  COPY statements are expanded.
The output is saved in file @file{*.i}.

@item -C
Translation only.  COBOL source files are translated into C files.
The output is saved in file @file{*.c}.

@item -S
Compile only.  Translated C files are compiled by the C compiler
to assembler code.
The output is saved in file @file{*.s}.

@item -c
Compile and assemble.  This is equivalent to @code{cc -c}.
The output is saved in file @file{*.o}.

@item -m
Compile, assemble, and build a dynamically loadable module (i.e.,
a shared library).  The output is saved in file @file{*.so}.
This is the default behaviour if not other options are given.
@footnote{The extension varies depending on your host.}.

@item -b
Compile, assemble, and combine all input files into a single
dynamically loadable module.  Unless @code{-o} is also used,
the output is saved using the first filename as @file{*.so}. 

@item -x
Include the main function in the output, creating an executable
image.  The main entry point being the outermost @code{PROGRAM-ID}.

This option takes effect at the translation stage.
If you give this option with @code{-C}, you will see the main
function at the end of the generated C file.

@item -I <directory>
Add <directory> to copy/include search path

@item -L <directory>
Add <directory> to library search path

@item -l <lib>
Link the library <lib>

@item -D <define>
Pass <define> to the COBOL compiler

@item -o <file>
Place the output into <file>

@end table

Without any options above, the compiler builds a
dynamically loadable module.

@node Source Format, Warning Options, Built Target, Compiler Options
@subsection Source Format

GNU Cobol supports both fixed and free source format.

The default format is the fixed format.  This can be explicitly
overwritten by one of the following options:

@table @code
@item -free
Free format.  The program-text area starts in column 1 and
continues till the end of line.  Effectively 255 characters
in GNU Cobol.

@item -fixed
Fixed format.  Source code is divided into a 1-6 column sequence
number area, column 7 indicator area, columns 8-72 program-text
area, with columns 72-80 as a reference area.  Historically this
format is based on 80 character punch cards.  FIXED format is the
default used by the compiler unless overridden by compiler switch
or source code directive, @code{>>SOURCE [FORMAT] [IS] @{FIXED|FREE@}}. 
@end table

@node Warning Options, Configuration Options, Source Format, Compiler Options
@subsection Warning Options

@table @code
@item -W
Enable every possible warning.  This includes more information
than -Wall would normally provide.

@item -Wall
Enable all common warnings

@item -Warchaic
Warn if archaic features are used

@item -Wcall-params
Warn non 01/77 items for CALL params (NOT set with -Wall)

@item -Wcolumn-overflow
Warn if text after column 72 in FIXED format (NOT set with -Wall)

@item -Wconstant
Warn inconsistent constant

@item -Wimplicit-define
Warn implicitly defined data items

@item -Wlinkage
Warn dangling LINKAGE items (NOT set with -Wall)

@item -Wobsolete
Warn if obsolete features are used

@item -Wparentheses
Warn lack of parentheses around AND within OR

@item -Wredefinition
Warn incompatible redefinition of data items

@item -Wstrict-typing
Warn type mismatch strictly

@item -Wterminator
Warn lack of scope terminator END-XXX (NOT set with -Wall)

@item -Wtruncate
Warn possible field truncation (NOT set with -Wall)

@item -Wunreachable
Warn unreachable statements (NOT set with -Wall)
@end table

@node Configuration Options, Debug Switches, Warning Options, Compiler Options
@subsection Configuration Options

@table @code
@item -std=<dialect>
Compiler uses the given dialect to determine certain compiler features
and warnings.@*
@xref{Appendix G, ,config/default.conf}, and @file{config/*.conf}.

@item -std=cobol2002
Cobol 2002

@item -std=cobol85
Cobol 85

@item -std=ibm
IBM Compatible

@item -std=mvs
MVS Compatible

@item -std=bs2000
BS2000 Compatible

@item -std=mf
Micro Focus Compatible

@item -std=default
When not specified

@item -conf=<file>
User defined dialect configuration. See @code{-std=} above.@*
@xref{Appendix G, ,config/default.conf}, and @file{config/*.conf}.

@end table

@node Debug Switches, Miscellaneous, Configuration Options, Compiler Options
@subsection Debug Switches

@table @code

@item -debug
Enable all run-time error checking

@item -g
Produce debugging information in the output

@item -O
Enable optimization of code size and execution speed.
See @code{man gcc} for details.

@item -O2
Optimize even more.

@item -Os
Optimize for size. Optimizer will favour code size over execution speed.

@item -ftrace
Generate trace code (Executed SECTION/PARAGRAPH)

@item -ftraceall
Generate trace code (Executed SECTION/PARAGRAPH/STATEMENTS)

@item -fsyntax-only
Syntax error checking only; don't emit any output

@item -fdebugging-line
Enable debugging lines ('D' in indicator column)

@item -fsource-location
Generate source location code (Turned on by -debug or -g)

@item -fimplicit-init
Do automatic initialization of the Cobol runtime system

@item -fstack-check
PERFORM stack checking (Turned on by -debug or -g)

@item -fnotrunc
Do not truncate binary fields according to PICTURE

@end table

@node Miscellaneous,  , Debug Switches, Compiler Options
@subsection Miscellaneous
@table @code

@item -P
Generate and place a program listing into @file{*.lst}

@item -ext <extension>
Add default file extension

@item -fmfcomment
'*' or '/' in column 1 treated as comment (FIXED only)

@item -fsign=ASCII
Numeric display sign ASCII (Default on ASCII machines)

@item -fsign=EBCDIC
Numeric display sign EBCDIC (Default on EBCDIC machines)

@item -ffunctions-all
Allow use of intrinsic functions without FUNCTION keyword

@item -ffold-copy=LOWER
Fold COPY subject to lower case (Default no transformation)

@item -ffold-copy=UPPER
Fold COPY subject to upper case (Default no transformation)

@item -save-temps(=<dir>)
Save intermediate files (default current directory)

@end table

@node Multiple Sources, C Interface, Compiler Options, Compile
@section Multiple Sources

A program often consists of multiple source files.  This section
describes how to compile multiple source files.

This section also describes how to build a shared library that can
be used by any COBOL programs and how to use external libraries from
COBOL programs.

@menu
* Static Linking::              Compiling into a single executable
* Dynamic Linking::             A main program and separate modules
* Building Library::            Building a shared library
* Using Library::               Using external libraries
@end menu

@node Static Linking, Dynamic Linking, Multiple Sources, Multiple Sources
@subsection Static Linking

The easiest way of combining multiple files is to compile them into a
single executable.

One way is to specify all files on the command line:

@example
$ cobc -x -o prog main.cob subr1.cob subr2.cob
@end example

Another way is to compile each file with the option @code{-c},
and link them at the end.
The top-level program must be compiled with the option @code{-x}:

@example
$ cobc -c subr1.cob
$ cobc -c subr2.cob
$ cobc -c -x main.cob
$ cobc -x -o prog main.o subr1.o subr2.o
@end example

You can link C routines as well using either method:

Method 1:
@example
$ cobc -o prog main.cob subrs.c
@end example

Method 2:
@example
$ cobc -c subrs.c
$ cobc -c -x main.cob
$ cobc -x -o prog main.o subrs.o
@end example

Any number of functions can be contained in a single C file.

The linked programs will be called dynamically; that is, the symbol
will be resolved at run time.  For example, the following COBOL
statement

@example
CALL "subr" USING X.
@end example

will be converted into an equivalent C code like this:

@example
int (*func)() = cob_resolve("subr");
if (func != NULL)
  func (X);
@end example

With the compiler options @code{-fstatic-call}, more efficient code
will be generated like this:

@example
subr(X);
@end example

Note that this option is effective only when the called program name
is a literal (like @code{CALL "subr".}).  With a data name (like
@code{CALL SUBR.}), the program is still called dynamically.

@node Dynamic Linking, Building Library, Static Linking, Multiple Sources
@subsection Dynamic Linking

There are two methods to achieve this.
Method 1 (Using driver program).
Compile all programs with the option @code{-m}:
@example
$ cobc -m main.cob subr.cob
@end example
This creates shared object files @file{main.so subr.so}
@footnote{The extension varies depending on your host.}.

Before running the main program, install the module files in your
library directory:
@example
$ cp subr.so /your/cobol/lib
@end example
Set the environment variable @code{COB_LIBRARY_PATH}
to your library directory, and run the main program:
@example
$ export COB_LIBRARY_PATH=/your/cobol/lib
@end example
Note: You may set the variable to directly point to the
directory where you compiled the sources.

Now execute your program:
@example
$ cobcrun main
@end example

Method 2.
The main program and subprograms can be compiled separately.

The main program is compiled as usual:
@example
$ cobc -x -o main main.cob
@end example

Subprograms are compiled with the option @code{-m}:
@example
$ cobc -m subr.cob
@end example
This creates a module file @file{subr.so}
@footnote{The extension varies depending on your host.}.

Before running the main program, install the module files in your
library directory:
@example
$ cp subr.so /your/cobol/lib
@end example

Now, set the environment variable @code{COB_LIBRARY_PATH}
to your library directory, and run the main program:
@example
$ export COB_LIBRARY_PATH=/your/cobol/lib
$ ./main
@end example

@node Building Library, Using Library, Dynamic Linking, Multiple Sources
@subsection Building Library

You can build a shared library by combining multiple COBOL programs
and even C routines:

@example
$ cobc -c subr1.cob
$ cobc -c subr2.cob
$ cc -c subr3.c
$ cc -shared -o libsubrs.so subr1.o subr2.o subr3.o
@end example

@node Using Library,  , Building Library, Multiple Sources
@subsection Using Library

You can use a shared library by linking it with your main program.

Before linking the library, install it in your system library directory:
@example
$ cp libsubrs.so /usr/lib
@end example
or install it somewhere else and set @code{LD_LIBRARY_PATH}:
@example
$ cp libsubrs.so /your/cobol/lib
$ export LD_LIBRARY_PATH=/your/cobol/lib
@end example

Then, compile the main program, linking the library as follows:
@example
$ cobc -x main.cob -L/your/cobol/lib -lsubrs
@end example

@node C Interface,  , Multiple Sources, Compile
@section C Interface

This chapter describes how to combine C programs with COBOL programs.

@menu
* Main C Program::              Writing Main Program in C
* Static C to COBOL::           
* Dynamic C to COBOL::          
* Static COBOL to C::           
* Dynamic COBOL to C::          
@end menu

@node Main C Program, Static C to COBOL, C Interface, C Interface
@subsection Writing Main Program in C

Include @file{libcob.h} in your C program.
Call @code{cob_init} before using any COBOL module:

@example
#include <libcob.h>

int
main (int argc, char **argv)
@{
  /* initialize your program */
  ...

  /* initialize the COBOL run-time library */
  cob_init (argc, argv);

  /* rest of your program */
  ...

  /* Clean up and terminate - This does not return */
  cob_stop_run (return_status);

@}
@end example

You can write @code{cobc_init(0, NULL);} if you do not want to pass
command line arguments to COBOL.

You can compile your C program as follows:

@example
cc -c `cob-config --cflags` main.c
@end example

The compiled object must be linked with libcob as follows:

@example
cc -o main main.o `cob-config --libs`
@end example

@node Static C to COBOL, Dynamic C to COBOL, Main C Program, C Interface
@subsection Static linking with COBOL programs

Let's call the following COBOL module from a C program:

@example
---- say.cob ---------------------------
       IDENTIFICATION DIVISION.
       PROGRAM-ID. say.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       LINKAGE SECTION.
       01 HELLO PIC X(6).
       01 WORLD PIC X(6).
       PROCEDURE DIVISION USING HELLO WORLD.
       DISPLAY HELLO WORLD.
       EXIT PROGRAM.
----------------------------------------
@end example

This program accepts two arguments, displays them, and exits.

From the viewpoint of C, this is equivalent to a function having the
following prototype:

@example
extern int say(char *hello, char *world);
@end example

So, your main program will look like as follows:

@example
---- hello.c ---------------------------
#include <libcob.h>

extern int say(char *hello, char *world);

int
main()
@{
  int ret;
  char hello[7] = "Hello ";
  char world[7] = "World!";

  cob_init(0, NULL);

  ret = say(hello, world);

  return ret;
@}
----------------------------------------
@end example

Compile these programs as follows:

@example
$ cc -c `cob-config --cflags` hello.c
$ cobc -c -static say.cob
$ cobc -x -o hello hello.o say.o
$ ./hello
Hello World!
@end example

@node Dynamic C to COBOL, Static COBOL to C, Static C to COBOL, C Interface
@subsection Dynamic linking with COBOL programs

You can find a COBOL module having a specific PROGRAM-ID by using a C
function @code{cob_resolve}, which takes the module name as a string
and returns a pointer to the module function.

@code{cob_resolve} returns NULL if there is no module.  In this case,
the function @code{cob_resolve_error} returns the error message.

Let's see an example:

@example
---- hello-dynamic.c -------------------
#include <libcob.h>

static int (*say)(char *hello, char *world);

int
main()
@{
  int ret;
  char hello[7] = "Hello ";
  char world[7] = "World!";

  cob_init(0, NULL);

  /* find the module with PROGRAM-ID "say". */
  say = cob_resolve("say");

  /* if there is no such module, show error and exit */
  if (say == NULL) @{
    fprintf(stderr, "%s\n", cob_resolve_error ());
    exit(1);
  @}

  /* call the module found and exit with the return code */
  ret = say(hello, world);

  return ret;
@}
----------------------------------------
@end example

Compile these programs as follows:

@example
$ cc -c `cob-config --cflags` hello-dynamic.c 
$ cobc -x -o hello hello-dynamic.o
$ cobc -m say.cob
$ export COB_LIBRARY_PATH=.
$ ./hello
Hello World!
@end example

@node Static COBOL to C, Dynamic COBOL to C, Dynamic C to COBOL, C Interface
@subsection Static linking with C programs

Let's call the following C function from COBOL:

@example
---- say.c -----------------------------
int
say(char *hello, char *world)
@{
  int i;
  for (i = 0; i < 6; i++)
    putchar(hello[i]);
  for (i = 0; i < 6; i++)
    putchar(world[i]);
  putchar('\n');
  return 0;
@}
----------------------------------------
@end example

This program is equivalent to the foregoing @file{say.cob}.

Note that, unlike C, the arguments passed from COBOL programs are not
terminated by the null character (i.e., @code{\0}).

You can call this function in the same way you call COBOL programs:

@example
---- hello.cob -------------------------
       IDENTIFICATION DIVISION.
       PROGRAM-ID. hello.
       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01 HELLO PIC X(6) VALUE "Hello ".
       01 WORLD PIC X(6) VALUE "World!".
       PROCEDURE DIVISION.
       CALL "say" USING HELLO WORLD.
       STOP RUN.
----------------------------------------
@end example

Compile these programs as follows:

@example
$ cc -c say.c
$ cobc -c -static -x hello.cob
$ cobc -x -o hello hello.o say.o
$ ./hello
Hello World!
@end example

@node Dynamic COBOL to C,  , Static COBOL to C, C Interface
@subsection Dynamic linking with C programs

You can create a dynamic-linking module from a C program by passing an
option @code{-shared} to the C compiler:

@example
$ cc -shared -o say.so say.c
$ cobc -x hello.cob
$ export COB_LIBRARY_PATH=.
$ ./hello
Hello World!
@end example

@node Customize, Optimize, Compile, Top
@chapter Customize

@menu
* Customizing Compiler::        Customizing Compiler
* Customizing Library::         Customizing Library
@end menu

@node Customizing Compiler, Customizing Library, Customize, Customize
@section Customizing Compiler

These settings are effective at compile-time.

Environment variables (default value):

@table @code
@item COB_CC
C compiler ("gcc")
@item COB_CFLAGS
Flags passed to the C compiler ("-I$(PREFIX)/include")
@item COB_LDFLAGS
Flags passed to the C compiler ("")
@item COB_LIBS
Standard libraries linked with the program ("-L$(PREFIX)/lib -lcob")
@item COB_LDADD
Additional libraries linked with the program ("")
@end table

@node Customizing Library,  , Customizing Compiler, Customize
@section Customizing Library

These settings are effective at run-time.

Environment variables (default value):

@table @code
@item COB_LIBRARY_PATH
Dynamic-linking module path (".:$(PREFIX)/lib/gnu-cobol")
@end table

@node Optimize, Debug, Customize, Top
@chapter Optimize

@menu
* Optimize Options::            How to enable optimization
* Optimize Call::               Call subroutines efficiently
* Optimize Binary::             Use efficient binary representation
@end menu

@node Optimize Options, Optimize Call, Optimize, Optimize
@section Optimize Options

There are three compiler options for optimization: @code{-O}, @code{-Os}
and @code{-O2}.  These options enable optimization at both translation
(from COBOL to C) and compilation (C to assembly) levels.

Currently, there is no difference between these optimization options at
the translation level.

The option @code{-O}, @code{-Os} or @code{-O2} is passed to the
C compiler as it is and used for C level optimization.

@node Optimize Call, Optimize Binary, Optimize Options, Optimize
@section Optimize Call

When a CALL statement is executed, the called program is linked at run
time.  By specifying the compiler option @code{-fstatic-call}, you can
statically link the program at compile time and call it efficiently.
(@pxref{Static Linking})

@node Optimize Binary,  , Optimize Call, Optimize
@section Optimize Binary

By default, data items of usage binary or comp are stored in the
big-endian form.  On those machines whose native byte order is
little-endian, this is not quite efficient.

If you prefer, you can store binary items in the native form of your
machine.  Set the config option @code{binary-byteorder} to
@code{native} in your config file (@pxref{Customize}).

In addition, setting the option @code{binary-size} to @code{2-4-8} or
@code{1-2-4-8} is more efficient than others.

@node Debug, System routines, Optimize, Top
@chapter Debug

@menu
* Debug Options::               Debug options
@end menu

@node Debug Options, , Debug, Debug
@section Debug Options

The compiler option @code{-debug} can be used during the development
of your programs.  It enables all run-time error checking, such as
subscript boundary checks and numeric data checks, and displays
run-time errors with source locations.

@exampleindent 0

@node System routines, Appendix A, Debug, Top
@chapter System routines

@menu
* CBL_OC_GETOPT::				CBL_OC_GETOPT
@end menu

@node CBL_OC_GETOPT, , System routines, System routines
@section CBL_OC_GETOPT

CBL_OC_GETOPT realises the quite well-known option parser getopt for 
GNU Cobol. The usage of this system routine is described by the 
following example.@*@*

@example
        identification division.
        program-id. prog.
        
        data division.
        working-storage section.
            78 shortoptions value "jkl".
        
            01 longoptions.
                05 optionrecord occurs 2 times.
                    10 optionname   pic x(25).
                    10 has-value    pic 9.
                    10 valpoint     pointer value NULL.
                    10 return-value pic x.
        
            01 longind     pic 99.
            01 long-only   pic 9 value 1.
        
            01 return-char pic x.
            01 opt-val     pic x(10).
            
            01 counter     pic 9 value 0.
@end example

@*@*
We first need to define the necessary fields for getopt's shortoptions (so), 
longoptions (lo), longoption index (longind), long-only-option (long-only) 
and also the fields for return values return-char and opt-val (arbitrary size with trimming, see return codes). @*
The shortoptions are written down as an alphanumeric field (string with arbitrary size) as follows: 
@*@*

@example
"ab:c::d"
@end example

@*@*
This means we want getopt to look for shortoptions named a, b, c or d and we demand an option 
value for b and we are accepting an optional one for c. @*@*
The longoptions are defined as a table of records with oname, has-value, valpoint and val. 
The field oname defines the name of a longoption, has-value defines if an option value is 
demanded(has-val = 1), optional(2) or not required(0). @*
The longoption structure is immutable! You can vary the amount of records only.
The pointer valpoint is used to specify an address to save getopt's return value to. The pointer 
is optional. If it is NULL, getopt returns a value as usual. @*
The field val is a single character which is returned if the longoption was recognized.@*@*
Now we have the tools to run CBL_OC_GETOPT within the procedure division.@*

@example
        procedure division.
            move "version" to optionname(1).
            move 0 to has-value(1).
            move "v" to return-value(1).
            
            move "verbose" to optionname(2).
            move 0 to has-value(2).
            move "V" to return-value(2).
        
            perform with test before until counter > 5
                call 'CBL_OC_GETOPT' using 
                by reference shortoptions longoptions longind
                by value long-only
                by reference return-char opt-val
                end-call
            
                display return-char end-display
                display opt-val end-display
                
                add 1 to counter end-add
            end-perform
            stop run.

@end example

@*@*
The example shows how we initialize all parameters and call the routine. We call 
getopt 6 times as we have 5 options to recognize and one additional call just to 
see that getopt returns '-1' in this case.@*@*
The return-char might contain the following:
@itemize @bullet
@item regular character if an option was recognized
@item '?' @ @ if we have got an undefined option 
@item '1' @ @ if got a non-option
@item '0' @ @ if valpoint != NULL and we are writing the return value to the specified address
@item '-1' @ if we don't have any more options
@end itemize
@*@*
The return-codes of CBL_OC_GETOPT are: 
@itemize @bullet
@item '1' @ @ if we've got a non-option
@item '0' @ @ if valpoint != NULL and we are writing the return value to the specified address
@item '-1' @ if we don't have any more options
@item '2' @ @ if we have got an truncated option value in opt-val (because opt-val was too small)
@item '3' @ @ if we got a regular answer from getopt
@end itemize
@*@*


@node Appendix A, Appendix B, System routines, Top
@appendix @code{cobc --help}

@include cbhelp.tex

@node Appendix B, Appendix C, Appendix A, Top
@appendix @code{cobc --info}

@include cbinfo.tex

@node Appendix C, Appendix D, Appendix B, Top
@appendix @code{cobc --list-reserved}

@include cbrese.tex

@node Appendix D, Appendix E, Appendix C, Top
@appendix @code{cobc --list-intrinsics}

@include cbintr.tex

@node Appendix E, Appendix F, Appendix D, Top
@appendix @code{cobc --list-system}

@include cbsyst.tex

@node Appendix F, , Appendix E, Top
@appendix @code{cobc --list-mnemonics}

@include cbmnem.tex

@node Appendix G, , , Top
@appendix config/default.conf

@include cbconf.tex

@bye

@c Local Variables:
@c mode:outline-minor
@c outline-regexp:"@\\(ch\\|sec\\|subs\\)"
@c End:
